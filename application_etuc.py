# -*- coding: utf-8 -*-
"""Application_Etuc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P-L8QSxN0fzb_4vOo91-yCvE28_e0wHG
"""

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
from networkx.classes import graph
#from numpy import inf
from IPython.display import display
from math import inf
import sys

#----------------------------Introduction à notre application---------------------------------
print("Bienvenue dans le projet du module Etuc qui a été élaboré par BENABED Anfel et AMINE Ishak.")
C=0
while C!= 3 :
  if __name__ == '__main__':

      print("Nous vous proposons les choix suivants :")
      print("1. Graphes valués")
      print("2. Algorithme de Prim")
      print("3. Sortir")
      C= float(input("Veuillez saisir votre choix s'il vous plait: \n"))

  if(C== 2) :
    G = nx.Graph()
    m=[]

    #Demander a l'utilisateur d'introduire le nombre de sommets (N) souhaités
    N = int(input("Veuillez introduire le nombre de sommets du graphe: "))
    print() #améliorer l'affichage des requetes

    #Création de la matrice de taille NxN contenant les valeurs que l'utilisateur aura choisi
    print("Veuillez introduire:") #améliorer l'affichage des requetes

    for i in range(0, N):
      P=[] # P: Poids
      print() #améliorer l'affichage des requetes
        
      #Remplir les poids entre le sommet actuel et tous les sommets du graphe
      for j in range(0, N):
        val=int(input("   Le poids entre le sommet "+ str(i+1)+" et "+str(j+1)+": "));
        P.append(val)
        if(not (val==0)): #Si le poids n'est pas nul, on l'ajoute à notre graphe
          G.add_edge(i+1, j+1,weight=val)

      m.append(P)

    #pos:position
    pos = nx.spring_layout(G)

    options = {
        "font_size": 15,
        "node_size": 1500,
        "node_color": '#D7AFAF',
        "edgecolors": '#D7AFAF',  
        "linewidths": 1,
        "width": 1,
    }

    labels = nx.get_edge_attributes(G,'weight')
    nx.draw_networkx_edge_labels(G,pos,edge_labels=labels)

    nx.draw_networkx(G,pos, **options)

    ax = plt.gca()
    ax.margins(0.10)
    plt.axis("off")
    ax.set_title('Le graphe initial G :')

    plt.show()

    #----------------------------Appliquer l'algorithme de prim sur le graphe G------------------------------!

    #Création d'un vecteur pour marquer un sommet s'il a deja été selectionné ou pas --> le vecteur : ListSS (Liste Sommets Séléctionnés)
    #Pour voir s'il fait partit des sommet de l'arbre couvrant de plus petit poids ou non
    ListSS = []
    for i in range(1, N+1):
      #Au debut, la liste ne contient rien car aucun sommet n'est encore selectionné
      ListSS.append(0)

    nbr_arretes = 0

    ListSS[0] = True #La selection du premier sommet du graphe pour pouvoir appliquer l'algorithme de prim

    G2 = nx.Graph() #G2 : L'arbre couvrant de poids min

    #le nombre d'arretes dans un arbre couvrant de poids min < N-1
    while (nbr_arretes < N-1):
        
        min = 99999999
        sommet_a = 0
        sommet_b = 0

        for sommet_c in range(N): #parcourrir tous les sommets du graphe
            if ListSS[sommet_c]: #si le sommet n'est pas deja selectionné

                for sommet_d in range(N):
                    if ((not ListSS[sommet_d]) and m[sommet_c][sommet_d]):
                        
                        if min > m[sommet_c][sommet_d]: #selectionner le sommet_d dont l'arrete est de poids minimum
                            min = m[sommet_c][sommet_d]
                            sommet_a = sommet_c
                            sommet_b = sommet_d

        G2.add_edge(sommet_a+1, sommet_b+1,weight=m[sommet_a][sommet_b]) #ajouuter les sommets ainsi que leurs poids à l'abre 
        ListSS[sommet_b] = True #marquer le sommet comme étant selectionné
        nbr_arretes += 1 #auguementer le nbr d'arretes de l'arbre couvrant de poids min

    #-----------------------------------------Affichage du graphe G2 l'abre couvrant de poids min de G----------------------------------!
    pos2 = nx.spring_layout(G2)
    options2 = {
        "font_size": 15,
        "node_size": 1500,
        "node_color": '#D7AFAF',
        "edgecolors": '#D7AFAF',  
        "linewidths": 1,
        "width": 1,
    }
    labels2 = nx.get_edge_attributes(G2,'weight')
    nx.draw_networkx_edge_labels(G2,pos2,edge_labels=labels2)

    nx.draw_networkx(G2,pos2, **options2)

    ax2 = plt.gca()
    ax2.margins(0.10)
    plt.axis("off")
    ax2.set_title('G2 : L\'arbre couvrant de poids minimal du graphe G')
    C=0

    plt.show()
    print("Vous pouvez essayez un autre choix.")
  #------------------------------------------------------------------------------------------------------------------------------------------------------------
  elif(C== 1):
      G = nx.Graph()
      m=[]

      #Demander a l'utilisateur d'introduire le nombre de sommets (N) souhaités
      N= int(input("Veuillez introduire le nombre de sommets du graphe: "))
      print() #améliorer l'affichage des requetes

      #Création de la matrice de taille NxN contenant les valeurs que l'utilisateur aura choisi
      print("Veuillez introduire:") #améliorer l'affichage des requetes

      for i in range(0, N):
        P=[] # P: Poids
        print() #améliorer l'affichage des requetes
          
        #Remplir les poids entre le sommet actuel et tous les sommets du graphe
        for j in range(0, N):
          val=int(input("   Le poids entre le sommet "+ str(i+1)+" et "+str(j+1)+": "));
          P.append(val)
          if(not (val==0)): #Si le poids n'est pas nul, on l'ajoute à notre graphe
            G.add_edge(i+1, j+1,weight=val)

        m.append(P)

      #pos:position
      pos = nx.spring_layout(G)

      options = {
          "font_size": 15,
          "node_size": 1500,
          "node_color": '#D7AFAF',
          "edgecolors": '#D7AFAF',  
          "linewidths": 1,
          "width": 1,
      }

      labels = nx.get_edge_attributes(G,'weight')
      nx.draw_networkx_edge_labels(G,pos,edge_labels=labels)

      nx.draw_networkx(G,pos, **options)

      ax = plt.gca()
      ax.margins(0.10)
      plt.axis("off")
      ax.set_title('Le graphe valué G :')
      C=0

      plt.show()
      print("Vous pouvez essayez un autre choix.")

  elif(C== 3) :
    print("Nous vous remerçions pour votre visite. A bientôt!")
    break
  
  elif(C>3) :
    print("Nous n'avons pas de solution pour votre choix.")